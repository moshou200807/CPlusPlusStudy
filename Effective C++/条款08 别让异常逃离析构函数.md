#### 一. 问题引入
> C++不禁止析构函数吐出异常。但它不鼓励你这样做。  
> C++无法处理两个以上的异常。如果有两个异常同时存在，程序要么结束执行，要么导致不明确行为。  


	class Widget {
	public:
	   ...
	   ~Widget() { ... } // 假设这里可能吐出一个异常
	};
	 
	void doSomething()
	{
	   std::vector<Widget> v;
	   ...
	} // v在这里被自动销毁。可能引发两个以上的异常。

#### 二. 改进
> 最好不要在析构函数中吐出异常。    

假设你的析构函数必须执行一个动作，而该动作可能会在失败时抛出异常：  

	class DBConn { // 这个类用来管理DBConnection对象
	public:        // objects
	  ...
	  ~DBConn()     // 确保数据库连接总是会被关闭
	   { 
	       db.close();	// 假设db.close()函数可能抛出异常
		}
	private:
	   DBConnection db;
	};

较普遍的修改方法：将异常在析构函数中捕获。  

	DBConn::~DBConn()
	{
	try { db.close(); }
	   catch (...) {
	        制作运转记录，记下对close的调用失败；
	        std::abort();	// 可以根据异常的实际影响决定是否需要终止程序运行。
	   }
	}

更好的修改方法：重新设计DBConn接口，使客户有机会处理异常，而不是固定将异常留给析构函数处理。  

	class DBConn {
	public:
	    ...
	    void close() // 供客户使用的新函数接口
	    {
	       db.close();
	       closed = true;
	    }
	 
	    ~DBConn()
	    {
	       if (!closed) {
	           try {
	               db.close(); 		// 关闭连接（如果客户不那么做的话）
	           } 
	           catch (...) { 		// 如果关闭动作失败，记录下来并结束程序或吞下异常
	               制作运转记录，记下对close的调用失败；
	               ...
	           }
	        }
	    }
	    private:
	        DBConnection db;
	        bool closed;
	};
如上，提供close接口，给客户处理异常的机会。  
如果某个操作可能在失败时抛出异常，而又存在某种需要必须处理该异常，那么这个异常必须来自析构函数以外的某个函数。因为**析构函数吐出异常就是危险的**。

#### 三. 总结
- 析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下他们（不传播）或结束程序。
- 如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作。