#### 一. 替换new和delete的合理时机
- **为了检测运用错误**。  
这些错误包括：内存泄漏、多次delete、写超出分配区的范围等。  
如果我们自行编写 operator new 和 operator delete，则可能检测出这些运用错误。  
- **为了收集动态分配内存的使用统计信息**。  
统计分配区块的大小、寿命、分配和归还规律、运用形态等。
- **为了强化效能**：
	- **为了增加分配和归还的速度**。  
分析了你的程序，并确认程序瓶颈发生在内存函数身上以后，就可以针对内存分配做一些优化。比如 Boost 提供的 Pool 程序库在划分海量小内存时独具优势；再比如你的程序是单线程，你可以抛弃编译器提供的具备线程安全性的内存函数从而提高速度。  
	- **为了降低缺省内存管理器带来的空间额外开销**。  
通用的内存管理器往往不只比定制型慢，还使用更多的内存，因为它们常常在每一个分配区块身上招引某些额外开销。  
针对小型对象而开发的分配器（比如 Boost 的 Pool 程序库）本质上消除了这样的额外开销。  
	- **为了弥补缺省分配器中的非最佳对齐位**。  
许多计算机体系结构要求特定的类型必须放在特定的内存地址上。比如它可能会要求指针的地址必须是 4 倍数；或 double 的地址必须是 8 倍数。如果没有奉行这个约束条件，可能导致运行期硬件异常；即便不发生硬件异常，也必然会影响效率。  
如果编译器自带的 operator news 不保证对齐要求，那么替换定制版本将会大大提高效率。  
	- **为了将相关对象簇集**。  
在某些程序中，特定的某个数据结构往往被一起使用。如果把它们簇集到相邻的内存位置，那么发生缺页中断的频率会降至最低，从而提高效率。  
new 和 delete 的 “placement版本” （见条款 52）有可能完成这样的簇集行为。  
	- **为了获得非传统的行为**。  
有时候你会希望 operator new 和 delete 做编译器附带版本没做的某些事情。比如你可能会希望分配和归还共享内存内的区块，这样你必须使用 C API 函数编写你的定制化 operator new 和 delete。

#### 二. 总结
- 有许多理由需要写个自定的 new 和 delete，包括改善性能、对 heap 运用错误进行调试、收集 heap 使用信息。